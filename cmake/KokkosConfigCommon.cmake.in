set(Kokkos_DEVICES @KOKKOS_ENABLED_DEVICES@)
set(Kokkos_OPTIONS @KOKKOS_ENABLED_OPTIONS@)
set(Kokkos_TPLS @KOKKOS_ENABLED_TPLS@)
set(Kokkos_ARCH @KOKKOS_ENABLED_ARCH_LIST@)
set(Kokkos_CXX_COMPILER "@CMAKE_CXX_COMPILER@")
set(Kokkos_CXX_COMPILER_ID "@KOKKOS_CXX_COMPILER_ID@")
set(Kokkos_CXX_COMPILER_VERSION "@KOKKOS_CXX_COMPILER_VERSION@")
set(Kokkos_CXX_STANDARD @KOKKOS_CXX_STANDARD@)

# Required to be a TriBITS-compliant external package
if(NOT TARGET Kokkos::all_libs)
  # CMake Error at <prefix>/lib/cmake/Kokkos/KokkosConfigCommon.cmake:10 (ADD_LIBRARY):
  #   ADD_LIBRARY cannot create ALIAS target "Kokkos::all_libs" because target
  #   "Kokkos::kokkos" is imported but not globally visible.
  if(CMAKE_VERSION VERSION_LESS "3.18")
    set_target_properties(Kokkos::kokkos PROPERTIES IMPORTED_GLOBAL ON)
  endif()
  add_library(Kokkos::all_libs ALIAS Kokkos::kokkos)
endif()

# Export Kokkos_ENABLE_<BACKEND> for each backend that was enabled.
# NOTE: "Devices" is a little bit of a misnomer here.  These are really
# backends, e.g. Kokkos_ENABLE_OPENMP, Kokkos_ENABLE_CUDA, Kokkos_ENABLE_HIP,
# or Kokkos_ENABLE_SYCL.
foreach(DEV ${Kokkos_DEVICES})
  set(Kokkos_ENABLE_${DEV} ON)
endforeach()
# Export relevant Kokkos_ENABLE<OPTION> variables, e.g.
# Kokkos_ENABLE_CUDA_RELOCATABLE_DEVICE_CODE, Kokkos_ENABLE_DEBUG, etc.
foreach(OPT ${Kokkos_OPTIONS})
  set(Kokkos_ENABLE_${OPT} ON)
endforeach()

if(Kokkos_ENABLE_CUDA)
  set(Kokkos_CUDA_ARCHITECTURES @KOKKOS_CUDA_ARCHITECTURES@)
endif()

if(Kokkos_ENABLE_HIP)
  set(Kokkos_HIP_ARCHITECTURES @KOKKOS_HIP_ARCHITECTURES@)
endif()

if(NOT Kokkos_FIND_QUIETLY)
  message(STATUS "Enabled Kokkos devices: ${Kokkos_DEVICES}")
endif()

if(Kokkos_ENABLE_CUDA)
  # If we are building CUDA, we have tricked CMake because we declare a CXX project
  # If the default C++ standard for a given compiler matches the requested
  # standard, then CMake just omits the -std flag in later versions of CMake
  # This breaks CUDA compilation (CUDA compiler can have a different default
  # -std then the underlying host compiler by itself). Setting this variable
  # forces CMake to always add the -std flag even if it thinks it doesn't need it
  set(CMAKE_CXX_STANDARD_DEFAULT 98 CACHE INTERNAL "" FORCE)
endif()

set(KOKKOS_USE_CXX_EXTENSIONS @KOKKOS_USE_CXX_EXTENSIONS@)
if(NOT DEFINED CMAKE_CXX_EXTENSIONS OR CMAKE_CXX_EXTENSIONS)
  if(NOT KOKKOS_USE_CXX_EXTENSIONS)
    message(
      WARNING "The installed Kokkos configuration does not support CXX extensions. Forcing -DCMAKE_CXX_EXTENSIONS=Off"
    )
    set(CMAKE_CXX_EXTENSIONS OFF CACHE BOOL "" FORCE)
  endif()
endif()

include(FindPackageHandleStandardArgs)

#   This function makes sure that Kokkos was built with the requested backends
#   and target architectures and generates a fatal error if it was not.
#
#   kokkos_check(
#     [DEVICES <devices>...]   # Set of backends (e.g. "OpenMP" and/or "Cuda")
#     [ARCH <archs>...]        # Target architectures (e.g. "Power9" and/or "Volta70")
#     [OPTIONS <options>...]   # Optional settings (e.g. "TUNING")
#     [TPLS <tpls>...]         # Third party libraries
#     [RETURN_VALUE <result>]  # Set a variable that indicates the result of the
#                              # check instead of a fatal error
#   )
function(kokkos_check)
  set(ALLOWED_ARGS DEVICES ARCH OPTIONS TPLS)
  cmake_parse_arguments(KOKKOS_CHECK "" "RETURN_VALUE" "${ALLOWED_ARGS}" ${ARGN})
  foreach(_arg ${KOKKOS_CHECK_UNPARSED_ARGUMENTS})
    message(SEND_ERROR "Argument '${_arg}' passed to kokkos_check() was not recognized")
  endforeach()
  # Get the list of keywords that were actually passed to the function.
  set(REQUESTED_ARGS)
  foreach(arg ${ALLOWED_ARGS})
    if(KOKKOS_CHECK_${arg})
      list(APPEND REQUESTED_ARGS ${arg})
    endif()
  endforeach()
  set(KOKKOS_CHECK_SUCCESS TRUE)
  foreach(arg ${REQUESTED_ARGS})
    # Define variables named after the required arguments that are provided by
    # the Kokkos install.
    foreach(requested ${KOKKOS_CHECK_${arg}})
      foreach(provided ${Kokkos_${arg}})
        string(TOUPPER ${requested} REQUESTED_UC)
        string(TOUPPER ${provided} PROVIDED_UC)
        if(PROVIDED_UC STREQUAL REQUESTED_UC)
          string(REPLACE ";" " " ${requested} "${KOKKOS_CHECK_${arg}}")
        endif()
      endforeach()
    endforeach()
    # Somewhat divert the CMake function below from its original purpose and
    # use it to check that there are variables defined for all required
    # arguments. Success or failure messages will be displayed but we are
    # responsible for signaling failure and skip the build system generation.
    if(KOKKOS_CHECK_RETURN_VALUE)
      set(Kokkos_${arg}_FIND_QUIETLY ON)
    endif()
    find_package_handle_standard_args("Kokkos_${arg}" DEFAULT_MSG ${KOKKOS_CHECK_${arg}})
    if(NOT Kokkos_${arg}_FOUND)
      set(KOKKOS_CHECK_SUCCESS FALSE)
    endif()
  endforeach()
  if(NOT KOKKOS_CHECK_SUCCESS AND NOT KOKKOS_CHECK_RETURN_VALUE)
    message(FATAL_ERROR "Kokkos does NOT provide all backends and/or architectures requested")
  else()
    set(${KOKKOS_CHECK_RETURN_VALUE} ${KOKKOS_CHECK_SUCCESS} PARENT_SCOPE)
  endif()
endfunction()

# A test to check whether a downstream project set the C++ compiler to NVCC or not
# this is called only when Kokkos was installed with Kokkos_ENABLE_CUDA=ON
function(kokkos_compiler_is_nvcc VAR COMPILER)
  # Check if the compiler is nvcc (which really means nvcc_wrapper).
  execute_process(
    COMMAND ${COMPILER} ${ARGN} --version
    OUTPUT_VARIABLE INTERNAL_COMPILER_VERSION
    OUTPUT_STRIP_TRAILING_WHITESPACE
    RESULT_VARIABLE RET
  )
  # something went wrong
  if(RET GREATER 0)
    set(${VAR} false PARENT_SCOPE)
  else()
    string(REPLACE "\n" " - " INTERNAL_COMPILER_VERSION_ONE_LINE ${INTERNAL_COMPILER_VERSION})
    string(FIND ${INTERNAL_COMPILER_VERSION_ONE_LINE} "nvcc" INTERNAL_COMPILER_VERSION_CONTAINS_NVCC)
    string(REGEX REPLACE "^ +" "" INTERNAL_HAVE_COMPILER_NVCC "${INTERNAL_HAVE_COMPILER_NVCC}")
    if(${INTERNAL_COMPILER_VERSION_CONTAINS_NVCC} GREATER -1)
      set(${VAR} true PARENT_SCOPE)
    else()
      set(${VAR} false PARENT_SCOPE)
    endif()
  endif()
endfunction()

# this function checks whether the current CXX compiler supports building CUDA
function(kokkos_cxx_compiler_cuda_test _VAR _COMPILER)

  file(
    WRITE ${PROJECT_BINARY_DIR}/compile_tests/compiles_cuda.cu
    "
#include <cuda.h>
#include <cstdlib>

__global__
void kernel(int sz, double* data)
{
    int _beg = blockIdx.x * blockDim.x + threadIdx.x;
    for(int i = _beg; i < sz; ++i)
        data[i] += static_cast<double>(i);
}

int main()
{
    double* data = NULL;
    int blocks = 64;
    int grids = 64;
    int ret = cudaMalloc(&data, blocks * grids * sizeof(double));
    if(ret != cudaSuccess)
        return EXIT_FAILURE;
    kernel<<<grids, blocks>>>(blocks * grids, data);
    cudaDeviceSynchronize();
    return EXIT_SUCCESS;
}
"
  )

  # save the command for debugging
  set(_COMMANDS "${_COMPILER} ${ARGN} -c ${PROJECT_BINARY_DIR}/compile_tests/compiles_cuda.cu")

  # use execute_process instead of try compile because we want to set custom compiler
  execute_process(
    COMMAND ${_COMPILER} ${ARGN} -c ${PROJECT_BINARY_DIR}/compile_tests/compiles_cuda.cu
    RESULT_VARIABLE _RET
    WORKING_DIRECTORY ${PROJECT_BINARY_DIR}/compile_tests
    TIMEOUT 15
    OUTPUT_QUIET ERROR_QUIET
  )

  if(NOT _RET EQUAL 0)
    # save the command for debugging
    set(_COMMANDS
        "${_COMMAND}\n${_COMPILER} --cuda-gpu-arch=sm_35 ${ARGN} -c ${PROJECT_BINARY_DIR}/compile_tests/compiles_cuda.cu"
    )
    # try the compile test again with clang arguments
    execute_process(
      COMMAND ${_COMPILER} --cuda-gpu-arch=sm_35 -c ${PROJECT_BINARY_DIR}/compile_tests/compiles_cuda.cu
      RESULT_VARIABLE _RET
      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}/compile_tests
      TIMEOUT 15
      OUTPUT_QUIET ERROR_QUIET
    )
  endif()

  set(${_VAR}_COMMANDS "${_COMMANDS}" PARENT_SCOPE)
  set(${_VAR} ${_RET} PARENT_SCOPE)
endfunction()

# this function sets the source and target properties that Kokkos requires
#
#       PROJECT           --> all cpp,cxx files for targets that link to kokkos in the project
#       DIRECTORY         --> all cpp,cxx files for targets that link to kokkos in given directories
#       TARGET            --> on the given targets
#       SOURCE            --> on the given source files
#       Kokkos_FOUND_DIR  --> hint on where Kokkos was installed (important for CMake contexts that don't know this but depend on Kokkos)
#
function(kokkos_set_source_and_target_properties)
  CMAKE_PARSE_ARGUMENTS(INP
        "PROJECT"
        "Kokkos_FOUND_DIR"
        "USE_LAUNCHER;DIRECTORY;TARGET;SOURCE"
        ${ARGN})

  #resolve projects to directories
  IF(INP_PROJECT)
    message(DEBUG "Kokkos marking directory ${PROJECT_SOURCE_DIR} to contain kokkos targets")
    LIST(APPEND INP_DIRECTORY ${PROJECT_SOURCE_DIR})
    UNSET(INP_PROJECT)
  ENDIF()

  #if nvcc use kokkos_launch_compiler to launch nvcc_wrapper
  IF(@Kokkos_ENABLE_CUDA@ AND @KOKKOS_CXX_COMPILER_ID@ STREQUAL NVIDIA AND NOT @Kokkos_ENABLE_COMPILE_AS_CMAKE_LANGUAGE@)
    IF(NOT Kokkos_COMPILE_LAUNCHER)
      # find kokkos_launch_compiler
      FIND_PROGRAM(Kokkos_COMPILE_LAUNCHER
          NAMES           kokkos_launch_compiler
          HINTS           ${INP_Kokkos_FOUND_DIR};${Kokkos_ROOT}
          PATHS           ${INP_Kokkos_FOUND_DIR};${Kokkos_ROOT}
          PATH_SUFFIXES   bin)
    ENDIF()

    IF(NOT Kokkos_COMPILE_LAUNCHER)
        MESSAGE(FATAL_ERROR "Kokkos could not find 'kokkos_launch_compiler'. Please set '-DKokkos_COMPILE_LAUNCHER=/path/to/launcher' or '-DKokkos_ROOT=/path/to/install'")
    ENDIF()

    IF(NOT Kokkos_NVCC_WRAPPER)
      # find nvcc_wrapper
      FIND_PROGRAM(Kokkos_NVCC_WRAPPER
          NAMES           nvcc_wrapper
          HINTS           ${INP_Kokkos_FOUND_DIR};${Kokkos_ROOT}
          PATHS           ${INP_Kokkos_FOUND_DIR};${Kokkos_ROOT}
          PATH_SUFFIXES   bin)
    ENDIF()
    # fatal if we can't nvcc_wrapper
    IF(NOT Kokkos_NVCC_WRAPPER)
        MESSAGE(FATAL_ERROR "Kokkos could not find nvcc_wrapper. Please set '-DKokkos_NVCC_WRAPPER=/path/to/nvcc_wrapper' or '-DKokkos_ROOT=/path/to/install'")
    ENDIF()

    kokkos_compilation(DIRECTORY ${INP_DIRECTORY} TARGET ${INP_TARGET} SOURCE ${INP_SOURCE} USE_LAUNCHER ${INP_USE_LAUNCHER};${Kokkos_COMPILE_LAUNCHER};${Kokkos_NVCC_WRAPPER};${CMAKE_CXX_COMPILER})

  ELSE() # all but nvcc 
    kokkos_compilation(DIRECTORY ${INP_DIRECTORY} TARGET ${INP_TARGET} SOURCE ${INP_SOURCE} USE_LAUNCHER ${INP_USE_LAUNCHER})
  ENDIF()
endfunction()


# this function searches a given directory recursively finding all targets that link to kokkos
#
#       FOUND_TARGETS    --> output: all found targets that link to kokkos
#       SEARCH_DIR       --> input: the root dir to start the recursion from 
#
function(kokkos_get_directory_targets FOUND_TARGETS SEARCH_DIR)

  # recursively visit subdirs
  get_property(subdirs DIRECTORY ${SEARCH_DIR} PROPERTY SUBDIRECTORIES)
  foreach(subdir ${subdirs})
      kokkos_get_directory_targets(subdir_targets ${subdir})
      list(APPEND targets ${subdir_targets})
  endforeach()

  #check if target links to Kokkos::kokkos
  get_property(parent_targets DIRECTORY ${SEARCH_DIR} PROPERTY BUILDSYSTEM_TARGETS)
  FOREACH(target IN LISTS parent_targets)
    #check if target links to kokkos
    get_target_property(target_libs ${target} INTERFACE_LINK_LIBRARIES)
    get_target_property(target_type ${target} TYPE)
    if(target_type STREQUAL "EXECUTABLE") # if executable cmake does not list the libs transitively so we visit all linked libs ourselves
      FOREACH(executable_linked_lib IN LISTS target_libs)
        get_target_property(dependent_libs ${executable_linked_lib} INTERFACE_LINK_LIBRARIES)
        if(Kokkos::kokkos IN_LIST dependent_libs)
          LIST(APPEND target_libs Kokkos::kokkos)
        endif()
      ENDFOREACH()
    endif()

    #if target links to kokkos, add it to targets and get the sources
    if(Kokkos::kokkos IN_LIST target_libs)
      message(DEBUG "Kokkos found target ${target} that links to Kokkos::kokkos in directory ${SEARCH_DIR}")
      LIST(APPEND targets ${target})
    endif()
  ENDFOREACH()

  # push results out of recursive function
  set(${FOUND_TARGETS} ${targets} PARENT_SCOPE)
endfunction()

# this function is provided to set the compiler and flags on dir/target/source that use Kokkos
#
#       USE_LAUNCHER  --> specify an optional compiler launcher
#       DIRECTORY     --> all cpp,cxx files for targets that link to kokkos in given directories
#       TARGET        --> on the given targets
#       SOURCE        --> on the given source files
#
FUNCTION(kokkos_compilation)
    CMAKE_PARSE_ARGUMENTS(COMP
        ""
        ""
        "USE_LAUNCHER;DIRECTORY;TARGET;SOURCE"
        ${ARGN})

    IF(@Kokkos_ENABLE_COMPILE_AS_CMAKE_LANGUAGE@)
      if(NOT DEFINED CMAKE_@KOKKOS_COMPILE_LANGUAGE@_COMPILER_LOADED)
        message(FATAL_ERROR "The used Kokkos needs @KOKKOS_COMPILE_LANGUAGE@ to be enabled to use the Kokkos_ENABLE_COMPILE_AS_CMAKE_LANGUAGE feature")
      endif()
    ENDIF()

    #set properties on directories
    FOREACH(directory IN LISTS COMP_DIRECTORY)
      kokkos_get_directory_targets(FOUND_DIRECTORY_TARGETS ${directory})
      list(APPEND COMP_TARGET ${FOUND_DIRECTORY_TARGETS})

      # set all cpp,cxx sources in the found targets to the correct language
      IF(@Kokkos_ENABLE_COMPILE_AS_CMAKE_LANGUAGE@)
        foreach(target IN LISTS FOUND_DIRECTORY_TARGETS)
          get_target_property(target_sources ${target} SOURCES)
          get_target_property(target_dir ${target} SOURCE_DIR)
          list(FILTER target_sources INCLUDE REGEX "\\.cpp$|\\.cxx$")
          message(DEBUG "Kokkos setting language to @KOKKOS_COMPILE_LANGUAGE@ on target ${target} for sources ${target_dir}/{${target_sources}}")
          foreach(source IN LISTS target_sources)
            set_property(SOURCE ${target_dir}/${source} TARGET_DIRECTORY ${target} PROPERTY LANGUAGE @KOKKOS_COMPILE_LANGUAGE@)
          endforeach()
        endforeach()
      ENDIF()

    ENDFOREACH()

    #set properties on sources
    foreach(source IN LISTS COMP_SOURCE)
      message(DEBUG "Kokkos setting language to @KOKKOS_COMPILE_LANGUAGE@ for source ${source}")
      set_property(SOURCE ${source} PROPERTY LANGUAGE @KOKKOS_COMPILE_LANGUAGE@)
    endforeach()

    #set properties on targets
    foreach(target IN LISTS COMP_TARGET)
      # use the language feature on targets
      IF(@Kokkos_ENABLE_COMPILE_AS_CMAKE_LANGUAGE@)
        message(DEBUG "Kokkos setting @KOKKOS_COMPILE_LANGUAGE@_ARCHITECTURES and @KOKKOS_COMPILE_LANGUAGE@_STANDARD on target ${target}")
        IF(@Kokkos_ENABLE_CUDA@)
          set_property(TARGET ${target} PROPERTY CUDA_ARCHITECTURES @KOKKOS_CUDA_ARCHITECTURES@)
          set_property(TARGET ${target} PROPERTY CUDA_STANDARD @KOKKOS_CXX_STANDARD@)
        ELSEIF(@Kokkos_ENABLE_HIP@)
          set_property(TARGET ${target} PROPERTY HIP_ARCHITECTURES @KOKKOS_HIP_ARCHITECTURES@)
          set_property(TARGET ${target} PROPERTY HIP_STANDARD @KOKKOS_CXX_STANDARD@)
        ENDIF()
      ENDIF()

      # use kokkos_launch_compiler on targets
      IF(COMP_USE_LAUNCHER)
        message(DEBUG "Kokkos setting compiler/linker launcher ${COMP_USE_LAUNCHER} on target ${target}")
        set_property(TARGET ${target} PROPERTY @KOKKOS_COMPILE_LANGUAGE@_COMPILER_LAUNCHER ${COMP_USE_LAUNCHER})
        set_property(TARGET ${target} PROPERTY @KOKKOS_COMPILE_LANGUAGE@_LINKER_LAUNCHER ${COMP_USE_LAUNCHER})
      ENDIF()

      # do nothing if the CXX compiler is capable of consuming kokkos directly
     endforeach()
ENDFUNCTION()

set(Kokkos_DEVICES @KOKKOS_ENABLED_DEVICES@)
set(Kokkos_OPTIONS @KOKKOS_ENABLED_OPTIONS@)
set(Kokkos_TPLS @KOKKOS_ENABLED_TPLS@)
set(Kokkos_ARCH @KOKKOS_ENABLED_ARCH_LIST@)
set(Kokkos_CXX_COMPILER "@CMAKE_CXX_COMPILER@")
set(Kokkos_BACKEND_COMPILER "@KOKKOS_BACKEND_COMPILER@")
set(Kokkos_CXX_COMPILER_ID "@KOKKOS_CXX_COMPILER_ID@")
set(Kokkos_CXX_COMPILER_VERSION "@KOKKOS_CXX_COMPILER_VERSION@")
set(Kokkos_CXX_STANDARD @KOKKOS_CXX_STANDARD@)

# Required to be a TriBITS-compliant external package
if(NOT TARGET Kokkos::all_libs)
  # CMake Error at <prefix>/lib/cmake/Kokkos/KokkosConfigCommon.cmake:10 (ADD_LIBRARY):
  #   ADD_LIBRARY cannot create ALIAS target "Kokkos::all_libs" because target
  #   "Kokkos::kokkos" is imported but not globally visible.
  if(CMAKE_VERSION VERSION_LESS "3.18")
    set_target_properties(Kokkos::kokkos PROPERTIES IMPORTED_GLOBAL ON)
  endif()
  add_library(Kokkos::all_libs ALIAS Kokkos::kokkos)
endif()

# Export Kokkos_ENABLE_<BACKEND> for each backend that was enabled.
# NOTE: "Devices" is a little bit of a misnomer here.  These are really
# backends, e.g. Kokkos_ENABLE_OPENMP, Kokkos_ENABLE_CUDA, Kokkos_ENABLE_HIP,
# or Kokkos_ENABLE_SYCL.
foreach(DEV ${Kokkos_DEVICES})
  set(Kokkos_ENABLE_${DEV} ON)
endforeach()
# Export relevant Kokkos_ENABLE<OPTION> variables, e.g.
# Kokkos_ENABLE_CUDA_RELOCATABLE_DEVICE_CODE, Kokkos_ENABLE_DEBUG, etc.
foreach(OPT ${Kokkos_OPTIONS})
  set(Kokkos_ENABLE_${OPT} ON)
endforeach()

if(Kokkos_ENABLE_CUDA)
  set(Kokkos_CUDA_ARCHITECTURES @KOKKOS_CUDA_ARCHITECTURES@)
endif()

if(Kokkos_ENABLE_HIP)
  set(Kokkos_HIP_ARCHITECTURES @KOKKOS_HIP_ARCHITECTURES@)
endif()

if(NOT Kokkos_FIND_QUIETLY)
  message(STATUS "Enabled Kokkos devices: ${Kokkos_DEVICES}")
endif()

if(Kokkos_ENABLE_CUDA)
  # If we are building CUDA, we have tricked CMake because we declare a CXX project
  # If the default C++ standard for a given compiler matches the requested
  # standard, then CMake just omits the -std flag in later versions of CMake
  # This breaks CUDA compilation (CUDA compiler can have a different default
  # -std then the underlying host compiler by itself). Setting this variable
  # forces CMake to always add the -std flag even if it thinks it doesn't need it
  set(CMAKE_CXX_STANDARD_DEFAULT 98 CACHE INTERNAL "" FORCE)
endif()

set(KOKKOS_USE_CXX_EXTENSIONS @KOKKOS_USE_CXX_EXTENSIONS@)
if(NOT DEFINED CMAKE_CXX_EXTENSIONS OR CMAKE_CXX_EXTENSIONS)
  if(NOT KOKKOS_USE_CXX_EXTENSIONS)
    message(
      WARNING "The installed Kokkos configuration does not support CXX extensions. Forcing -DCMAKE_CXX_EXTENSIONS=Off"
    )
    set(CMAKE_CXX_EXTENSIONS OFF CACHE BOOL "" FORCE)
  endif()
endif()

#   This function makes sure that Kokkos was built with the requested backends
#   and target architectures and generates a fatal error if it was not.
#
#   kokkos_check(
#     [DEVICES <devices>...]   # Set of backends (e.g. "OpenMP" and/or "Cuda")
#     [ARCH <archs>...]        # Target architectures (e.g. "Power9" and/or "Volta70")
#     [OPTIONS <options>...]   # Optional settings (e.g. "TUNING")
#     [TPLS <tpls>...]         # Third party libraries
#     [RETURN_VALUE <result>]  # Set a variable that indicates the result of the
#                              # check instead of a fatal error
#   )
function(kokkos_check)
  set(ALLOWED_ARGS DEVICES ARCH OPTIONS TPLS)
  cmake_parse_arguments(KOKKOS_CHECK "" "RETURN_VALUE" "${ALLOWED_ARGS}" ${ARGN})
  foreach(_arg ${KOKKOS_CHECK_UNPARSED_ARGUMENTS})
    message(SEND_ERROR "Argument '${_arg}' passed to kokkos_check() was not recognized")
  endforeach()
  # Get the list of keywords that were actually passed to the function.
  set(REQUESTED_ARGS)
  foreach(arg ${ALLOWED_ARGS})
    if(KOKKOS_CHECK_${arg})
      list(APPEND REQUESTED_ARGS ${arg})
    endif()
  endforeach()
  set(KOKKOS_CHECK_SUCCESS TRUE)
  foreach(arg ${REQUESTED_ARGS})
    set(MISSING_OPTIONS "")
    foreach(requested ${KOKKOS_CHECK_${arg}})
      set(FOUND_MATCHING_OPTION FALSE)
      foreach(provided ${Kokkos_${arg}})
        string(TOUPPER ${requested} REQUESTED_UC)
        string(TOUPPER ${provided} PROVIDED_UC)
        if(PROVIDED_UC STREQUAL REQUESTED_UC)
          set(FOUND_MATCHING_OPTION TRUE)
        endif()
      endforeach()
      if(NOT FOUND_MATCHING_OPTION)
        list(APPEND MISSING_OPTIONS ${requested})
        set(KOKKOS_CHECK_SUCCESS FALSE)
      endif()
    endforeach()
    if(NOT KOKKOS_CHECK_SUCCESS AND NOT KOKKOS_CHECK_RETURN_VALUE)
      message(STATUS "Could NOT find Kokkos_${arg} (missing: ${MISSING_OPTIONS})")
    endif()
  endforeach()
  if(NOT KOKKOS_CHECK_SUCCESS AND NOT KOKKOS_CHECK_RETURN_VALUE)
    message(FATAL_ERROR "Kokkos does NOT provide all backends and/or architectures requested")
  else()
    set(${KOKKOS_CHECK_RETURN_VALUE} ${KOKKOS_CHECK_SUCCESS} PARENT_SCOPE)
  endif()
endfunction()

# A test to check whether a downstream project set the C++ compiler to NVCC or not
# this is called only when Kokkos was installed with Kokkos_ENABLE_CUDA=ON
function(kokkos_compiler_is_nvcc VAR COMPILER)
  # Check if the compiler is nvcc (which really means nvcc_wrapper).
  execute_process(
    COMMAND ${COMPILER} ${ARGN} --version
    OUTPUT_VARIABLE INTERNAL_COMPILER_VERSION
    OUTPUT_STRIP_TRAILING_WHITESPACE
    RESULT_VARIABLE RET
  )
  # something went wrong
  if(RET GREATER 0)
    set(${VAR} false PARENT_SCOPE)
  else()
    string(REPLACE "\n" " - " INTERNAL_COMPILER_VERSION_ONE_LINE ${INTERNAL_COMPILER_VERSION})
    string(FIND ${INTERNAL_COMPILER_VERSION_ONE_LINE} "nvcc" INTERNAL_COMPILER_VERSION_CONTAINS_NVCC)
    string(REGEX REPLACE "^ +" "" INTERNAL_HAVE_COMPILER_NVCC "${INTERNAL_HAVE_COMPILER_NVCC}")
    if(${INTERNAL_COMPILER_VERSION_CONTAINS_NVCC} GREATER -1)
      set(${VAR} true PARENT_SCOPE)
    else()
      set(${VAR} false PARENT_SCOPE)
    endif()
  endif()
endfunction()

# this function checks whether the current CXX compiler supports building CUDA
function(kokkos_cxx_compiler_cuda_test _VAR _COMPILER)

  file(
    WRITE ${PROJECT_BINARY_DIR}/compile_tests/compiles_cuda.cu
    "
#include <cuda.h>
#include <cstdlib>

__global__
void kernel(int sz, double* data)
{
    int _beg = blockIdx.x * blockDim.x + threadIdx.x;
    for(int i = _beg; i < sz; ++i)
        data[i] += static_cast<double>(i);
}

int main()
{
    double* data = NULL;
    int blocks = 64;
    int grids = 64;
    int ret = cudaMalloc(&data, blocks * grids * sizeof(double));
    if(ret != cudaSuccess)
        return EXIT_FAILURE;
    kernel<<<grids, blocks>>>(blocks * grids, data);
    cudaDeviceSynchronize();
    return EXIT_SUCCESS;
}
"
  )

  # save the command for debugging
  set(_COMMANDS "${_COMPILER} ${ARGN} -c ${PROJECT_BINARY_DIR}/compile_tests/compiles_cuda.cu")

  # use execute_process instead of try compile because we want to set custom compiler
  execute_process(
    COMMAND ${_COMPILER} ${ARGN} -c ${PROJECT_BINARY_DIR}/compile_tests/compiles_cuda.cu
    RESULT_VARIABLE _RET
    WORKING_DIRECTORY ${PROJECT_BINARY_DIR}/compile_tests
    TIMEOUT 15
    OUTPUT_QUIET ERROR_QUIET
  )

  if(NOT _RET EQUAL 0)
    # save the command for debugging
    set(_COMMANDS
        "${_COMMAND}\n${_COMPILER} --cuda-gpu-arch=sm_35 ${ARGN} -c ${PROJECT_BINARY_DIR}/compile_tests/compiles_cuda.cu"
    )
    # try the compile test again with clang arguments
    execute_process(
      COMMAND ${_COMPILER} --cuda-gpu-arch=sm_35 -c ${PROJECT_BINARY_DIR}/compile_tests/compiles_cuda.cu
      RESULT_VARIABLE _RET
      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}/compile_tests
      TIMEOUT 15
      OUTPUT_QUIET ERROR_QUIET
    )
  endif()

  set(${_VAR}_COMMANDS "${_COMMANDS}" PARENT_SCOPE)
  set(${_VAR} ${_RET} PARENT_SCOPE)
endfunction()

# this function finds the kokkos_launch_compiler script and prepends it to the compiler and linker launcher
#
#       SEARCH_PATH       --> input: search path for kokkos_launch_compiler (optional)
#       BACKEND_COMPILER  --> input: compiler to be mapped to by the launcher (optional)
#
function(kokkos_use_launch_compiler)
  cmake_parse_arguments(INP "" "SEARCH_PATH;BACKEND_COMPILER" "" ${ARGN})
  if(@Kokkos_ENABLE_COMPILE_AS_CMAKE_LANGUAGE@)
    message(
      FATAL_ERROR "Setting kokkos_launch_compiler works only with `-DKokkos_ENABLE_COMPILE_AS_CMAKE_LANGUAGE=OFF`"
    )
  endif()
  find_program(
    Kokkos_COMPILE_LAUNCHER
    NAMES kokkos_launch_compiler
    HINTS ${Kokkos_ROOT};${INP_SEARCH_PATH}
    PATHS ${Kokkos_ROOT};${INP_SEARCH_PATH}
    PATH_SUFFIXES bin
  )
  if(NOT Kokkos_COMPILE_LAUNCHER)
    message(
      FATAL_ERROR
        "Kokkos could not find 'kokkos_launch_compiler'. Please set '-DKokkos_COMPILE_LAUNCHER=/path/to/launcher' or '-DKokkos_ROOT=/path/to/install'"
    )
  endif()
  if(NOT INP_BACKEND_COMPILER)
    set(INP_BACKEND_COMPILER ${Kokkos_BACKEND_COMPILER})
  endif()
  set(CMAKE_CXX_COMPILER_LAUNCHER
      ${CMAKE_CXX_COMPILER_LAUNCHER};${Kokkos_COMPILE_LAUNCHER};${INP_BACKEND_COMPILER};${CMAKE_CXX_COMPILER}
      PARENT_SCOPE
  )
  set(CMAKE_CXX_LINKER_LAUNCHER
      ${CMAKE_CXX_LINKER_LAUNCHER};${Kokkos_COMPILE_LAUNCHER};${INP_BACKEND_COMPILER};${CMAKE_CXX_COMPILER}
      PARENT_SCOPE
  )

endfunction()

# this function searches a list and checks if any of a given list of items is contained
#
#       LIST         --> input: the list to search
#       ITEMLIST     --> input: the list of items to find
#       RETURN_VAR   --> output: ON if any of the items in itemlist are contained in list
#
function(kokkos_any_item_in_list)
  cmake_parse_arguments(ARG "" "RETURN_VAR" "LIST;ITEMLIST" ${ARGN})
  if(ARG_UNPARSED_ARGUMENTS)
    message(FATAL_ERROR "'kokkos_any_item_in_list' has unrecognized arguments: ${ARG_UNPARSED_ARGUMENTS}")
  endif()

  set(${ARG_RETURN_VAR} OFF PARENT_SCOPE)
  foreach(ITEM IN LISTS ARG_ITEMLIST)
    if(${ITEM} IN_LIST ARG_LIST)
      set(${ARG_RETURN_VAR} ON PARENT_SCOPE)
      return()
    endif()
  endforeach()
endfunction()

# this function searches a given target recursively looking for a transitive compile dependency to DEPENDENT_LIBRARY
#
#       COMPILE_DEPENDENCY                  --> output: is set to ON if the target needs to be compiled with the requirements of DEPENDENT_LIBRARY
#       TRANSITIVE_COMPILE_DEPENDENCY       --> output: is set to ON if the target infects targets that depend PUBLIC on it to need to be compiled with the requirements of DEPENDENT_LIBRARY
#       DEPENDENT_LIBRARY                   --> input: The library to search for in the target properties
#       INVESTIGATED_TARGET                 --> input: target to be checked for transitive dependency
#       COMPILE_DEPENDENCY_CACHE            --> in/out: cache of targetnames that have a compile dependency on INVESTIGATED_TARGET
#       TRANSITIVE_COMPILE_DEPENDENCY_CACHE --> in/out: cache of targetnames that have a transient compile dependency on INVESTIGATED_TARGET
#
function(
  kokkos_check_compile_dependency
  COMPILE_DEPENDENCY
  TRANSITIVE_COMPILE_DEPENDENCY
  LINK_DEPENDENCY
  DEPENDENT_LIBRARY
  INVESTIGATED_TARGET
  COMPILE_DEPENDENCY_CACHE
  TRANSITIVE_COMPILE_DEPENDENCY_CACHE
)
  set(transitive_dependency OFF)
  set(compile_dependency OFF)
  set(link_dependency OFF)
  if(TARGET ${INVESTIGATED_TARGET})
    set(dependencies "")
    get_target_property(target_link_dependencies_genex ${INVESTIGATED_TARGET} LINK_LIBRARIES)
    string(GENEX_STRIP ${target_link_dependencies_genex} target_link_dependencies)
    if(target_link_dependencies)
      list(APPEND dependencies ${target_link_dependencies})
    endif()
    get_target_property(target_interface_dependencies_genex ${INVESTIGATED_TARGET} INTERFACE_LINK_LIBRARIES)
    string(GENEX_STRIP ${target_interface_dependencies_genex} target_interface_dependencies)
    if(target_interface_dependencies)
      list(APPEND dependencies ${target_interface_dependencies})
    endif()
    list(REMOVE_DUPLICATES dependencies)
    if(dependencies)
      #check the target directly
      kokkos_any_item_in_list(LIST ${dependencies} ITEMLIST ${DEPENDENT_LIBRARY} RETURN_VAR MATCH_FOUND)
      if(MATCH_FOUND)
        set(compile_dependency ON)
        set(link_dependency ON)
        if(target_interface_dependencies)
          kokkos_any_item_in_list(
            LIST ${target_interface_dependencies} ITEMLIST ${DEPENDENT_LIBRARY} RETURN_VAR MATCH_FOUND
          )
          if(MATCH_FOUND)
            set(transitive_dependency ON)
          endif()
        endif()
        #if no direct dependency is found check all dependencies
      else()
        # check cache
        set(cache_hit OFF)
        foreach(dependency IN LISTS dependencies)
          if(${dependency} IN_LIST ${COMPILE_DEPENDENCY_CACHE})
            set(link_dependency ON)
          endif()
          if(${dependency} IN_LIST ${TRANSITIVE_COMPILE_DEPENDENCY_CACHE})
            set(compile_dependency ON)
            #and if we link PUBLIC to it we get infectious, too
            if(target_interface_dependencies)
              if(${dependency} IN_LIST target_interface_dependencies)
                set(transitive_dependency ON)
                set(cache_hit ON)
                break() #we can end the cache checking
              endif()
            endif()
          endif()
        endforeach()
        # do recursion
        if(NOT cache_hit)
          foreach(dependency IN LISTS dependencies)
            kokkos_check_compile_dependency(
              depends_direct
              depends_transitively
              depends_linking
              "${DEPENDENT_LIBRARY}"
              ${dependency}
              ${COMPILE_DEPENDENCY_CACHE}
              ${TRANSITIVE_COMPILE_DEPENDENCY_CACHE}
            )
            if(depends_linking)
              set(link_dependency ON)
            endif()

            #if a dependency is infectious
            if(depends_transitively)
              set(compile_dependency ON)
              #and if we link PUBLIC to it we get infectious, too
              if(target_interface_dependencies)
                if(${dependency} IN_LIST target_interface_dependencies)
                  set(transitive_dependency ON)
                endif()
              endif()
            endif()
          endforeach()
        endif()
      endif()
    endif()
  endif()

  set(${COMPILE_DEPENDENCY} ${compile_dependency} PARENT_SCOPE)
  set(${TRANSITIVE_COMPILE_DEPENDENCY} ${transitive_dependency} PARENT_SCOPE)
  set(${LINK_DEPENDENCY} ${link_dependency} PARENT_SCOPE)

  if(link_dependency)
    list(APPEND ${COMPILE_DEPENDENCY_CACHE} ${INVESTIGATED_TARGET})
  endif()
  set(${COMPILE_DEPENDENCY_CACHE} "${${COMPILE_DEPENDENCY_CACHE}}" PARENT_SCOPE)

  if(transitive_dependency)
    list(APPEND ${TRANSITIVE_COMPILE_DEPENDENCY_CACHE} ${INVESTIGATED_TARGET})
  endif()
  set(${TRANSITIVE_COMPILE_DEPENDENCY_CACHE} "${${TRANSITIVE_COMPILE_DEPENDENCY_CACHE}}" PARENT_SCOPE)
endfunction()

# this function searches a given directory recursively finding all targets that link to DEPENDENT_LIBRARY
#
#       FOUND_TARGETS         --> output: list of all found targets that link to kokkos and need our compiler
#       DEPENDENT_LIBRARY     --> input: The library to search for in the target properties
#       SEARCH_DIR            --> input: the root dir to start the recursion from
#       EXCLUDE_DIRS          --> input: list of directories that should be excluded
#
function(kokkos_get_directory_targets)
  cmake_parse_arguments(INP "" "SEARCH_DIR" "FOUND_TARGETS;EXCLUDE_DIRS" ${ARGN})
  set(targets "")
  set(subdirs "")

  if(${INP_SEARCH_DIR} IN_LIST INP_EXCLUDE_DIRS)
    message(
      DEBUG
      "Kokkos excludes dir ${INP_SEARCH_DIR} from setting build options as it was marked to be excluded by `kokkos_exclude_from_setting_build_properties`"
    )
  else()
    get_property(targets DIRECTORY ${INP_SEARCH_DIR} PROPERTY BUILDSYSTEM_TARGETS)
    get_property(subdirs DIRECTORY ${INP_SEARCH_DIR} PROPERTY SUBDIRECTORIES)
  endif()

  # recursively visit subdirs
  if(subdirs)
    foreach(subdir ${subdirs})
      kokkos_get_directory_targets(FOUND_TARGETS subdir_targets SEARCH_DIR ${subdir} EXCLUDE_DIRS ${INP_EXCLUDE_DIRS})
      list(APPEND targets ${subdir_targets})
    endforeach()
  endif()

  # push results out of recursive function
  set(${INP_FOUND_TARGETS} ${targets} PARENT_SCOPE)
endfunction()

# this function searches a given directory recursively finding all targets that link to DEPENDENT_LIBRARY
#
#       GLOBAL         --> input: exclude everything from Kokkos setting build properties
#       DIRECTORY      --> input: list of directories that should be excluded
#
function(kokkos_exclude_from_setting_build_properties)
  cmake_parse_arguments(INP "GLOBAL" "" "DIRECTORY" ${ARGN})

  if(INP_GLOBAL)
    kokkos_exclude_from_setting_build_properties(DIRECTORY ${CMAKE_SOURCE_DIR})
  else()
    set(Kokkos_EXCLUDE_BUILD_DIRS
        "${INP_DIRECTORY};${Kokkos_EXCLUDE_DIRS}"
        CACHE
          STRING
          "List of directories Kokkos that are excluded from Kokkos setting build properties on source and target properties via a deferred call"
          FORCE
    )
  endif()
endfunction()

# this function sets the source and target properties for all targets that link to a given library
#
#       LIBRARY                 --> input: name of the library downstream targets need to link to for this function to set the properties.
#       USE_COMPILER_LAUNCHER   --> input: Command for a compiler launcher to use
#       USE_LINKER_LAUNCHER     --> input: Command for a linker launcher to use
#
function(kokkos_set_dependent_library_properties)
  cmake_parse_arguments(INP "" "" "LIBRARY;USE_COMPILER_LAUNCHER;USE_LINKER_LAUNCHER" ${ARGN})

  if(INP_UNPARSED_ARGUMENTS)
    message(
      FATAL_ERROR "'kokkos_set_dependent_library_properties' has unrecognized arguments: ${INP_UNPARSED_ARGUMENTS}"
    )
  endif()

  if(NOT INP_LIBRARY)
    message(FATAL_ERROR "'kokkos_set_dependent_library_properties' needs a LIBRARY argument")
  endif()

  kokkos_check_compile_dependency(
    library_compile_dependency
    library_transitive_compile_dependency
    library_link_dependency
    "Kokkos::kokkoscore;Kokkos::kokkoscontainers;Kokkos::kokkosalgorithms;Kokkos::kokkossimd;Kokkos::kokkos"
    ${INP_LIBRARY}
    KOKKOS_LINK_DEPENDENCY_CACHE
    KOKKOS_PUBLIC_DEPENDENCY_CACHE
  )

  kokkos_get_directory_targets(FOUND_TARGETS DIRECTORY_TARGETS SEARCH_DIR ${CMAKE_SOURCE_DIR})

  foreach(directory_target IN LISTS DIRECTORY_TARGETS)
    kokkos_check_compile_dependency(
      compile_dependency
      transitive_compile_dependency
      link_dependency
      "${INP_LIBRARY}"
      ${directory_target}
      ${INP_LIBRARY}_LINK_DEPENDENCY_CACHE
      ${INP_LIBRARY}_PUBLIC_DEPENDENCY_CACHE
    )
    if(compile_dependency)
      list(APPEND COMPILE_TARGETS ${directory_target})
    endif()

    if(link_dependency)
      list(APPEND LINK_TARGETS ${directory_target})
    endif()
  endforeach()

  if(library_transitive_compile_dependency)
    kokkos_set_source_and_target_properties(
      USE_COMPILER_LAUNCHER ${INP_USE_COMPILER_LAUNCHER} USE_LINKER_LAUNCHER ${INP_USE_LINKER_LAUNCHER} TARGET
      ${COMPILE_TARGETS}
    )
  endif()

  kokkos_set_source_and_target_properties(
    USE_COMPILER_LAUNCHER ${INP_USE_COMPILER_LAUNCHER} USE_LINKER_LAUNCHER ${INP_USE_LINKER_LAUNCHER} LINK_ONLY_TARGET
    ${LINK_TARGETS}
  )
endfunction()

# this function sets the source and target properties for all targets that link to a given library but deferred to the end of the CMake setup
#
#       LIBRARY                 --> input: name of the library downstream targets need to link to for this function to set the properties.
#       USE_COMPILER_LAUNCHER   --> input: Command for a compiler launcher to use
#       USE_LINKER_LAUNCHER     --> input: Command for a linker launcher to use
#
function(kokkos_defer_set_dependent_library_properties)
  cmake_parse_arguments(ARG "" "" "LIBRARY;USE_COMPILER_LAUNCHER;USE_LINKER_LAUNCHER" ${ARGN})

  if(ARG_UNPARSED_ARGUMENTS)
    message(
      FATAL_ERROR
        "'kokkos_defer_set_dependent_library_properties' has unrecognized arguments: ${ARG_UNPARSED_ARGUMENTS}"
    )
  endif()

  if(NOT ARG_LIBRARY)
    message(FATAL_ERROR "'kokkos_defer_set_dependent_library_properties' needs a LIBRARY argument")
  endif()

  cmake_language(
    EVAL
    CODE
    "cmake_language(DEFER DIRECTORY ${CMAKE_SOURCE_DIR} CALL kokkos_set_dependent_library_properties USE_COMPILER_LAUNCHER ${ARG_USE_COMPILER_LAUNCHER} USE_LINKER_LAUNCHER ${ARG_USE_LINKER_LAUNCHER} LIBRARY ${ARG_LIBRARY})"
  )

endfunction()

# this function sets the source and target properties that Kokkos requires
#
#       GLOBAL                  --> all cpp,cxx files for targets that link to kokkos in the project
#       DIRECTORY               --> all cpp,cxx files for targets that link to kokkos in given directories
#       TARGET                  --> on the given targets (that need compilation and link settings)
#       LINK_ONLY_TARGET        --> on the given targets (that only need link settings)
#       SOURCE                  --> on the given source files
#       USE_COMPILER_LAUNCHER   --> use given compiler launcher
#       USE_LINKER_LAUNCHER     --> use given linker launcher
#       Kokkos_FOUND_DIR        --> hint on where Kokkos was installed (important for CMake contexts that don't know this but depend on Kokkos)
#
function(kokkos_set_source_and_target_properties)
  cmake_parse_arguments(
    INP "GLOBAL" "Kokkos_FOUND_DIR"
    "USE_COMPILER_LAUNCHER;USE_LINKER_LAUNCHER;DIRECTORY;TARGET;LINK_ONLY_TARGET;SOURCE" ${ARGN}
  )

  if(INP_UNPARSED_ARGUMENTS)
    message(
      FATAL_ERROR "'kokkos_set_source_and_target_properties' has unrecognized arguments: ${INP_UNPARSED_ARGUMENTS}"
    )
  endif()

  if(@Kokkos_ENABLE_CUDA@)
    kokkos_cxx_compiler_cuda_test(CXX_COMPILER_COMPILES_CUDA ${CMAKE_CXX_COMPILER})
    if(CXX_COMPILER_COMPILES_CUDA)
      return()
    endif()
  else()
    return()
  endif()

  #if you passed a launcher, we will just take it without modification. If not we still use our launcher for CUDA if nvcc is not the global cxx compiler
  if((NOT INP_USE_COMPILER_LAUNCHER) AND (NOT INP_USE_LINKER_LAUNCHER))
    if(NOT CXX_COMPILER_COMPILES_CUDA)
      #use kokkos_launch_compiler to launch nvcc_wrapper
        if(NOT Kokkos_COMPILE_LAUNCHER)
          # find kokkos_launch_compiler
          find_program(
            Kokkos_COMPILE_LAUNCHER
            NAMES kokkos_launch_compiler
            HINTS ${INP_Kokkos_FOUND_DIR};${Kokkos_ROOT}
            PATHS ${INP_Kokkos_FOUND_DIR};${Kokkos_ROOT}
            PATH_SUFFIXES bin
          )
        endif()

        if(NOT Kokkos_COMPILE_LAUNCHER)
          message(
            FATAL_ERROR
              "Kokkos could not find 'kokkos_launch_compiler'. Please set '-DKokkos_COMPILE_LAUNCHER=/path/to/launcher' or '-DKokkos_ROOT=/path/to/install'"
          )
        endif()

        if(NOT Kokkos_NVCC_WRAPPER)
          # find nvcc_wrapper
          find_program(
            Kokkos_NVCC_WRAPPER
            NAMES nvcc_wrapper
            HINTS ${INP_Kokkos_FOUND_DIR};${Kokkos_ROOT}
            PATHS ${INP_Kokkos_FOUND_DIR};${Kokkos_ROOT}
            PATH_SUFFIXES bin
          )
        endif()
        # fatal if we can't nvcc_wrapper
        if(NOT Kokkos_NVCC_WRAPPER)
          message(
            FATAL_ERROR
              "Kokkos could not find nvcc_wrapper. Please set '-DKokkos_NVCC_WRAPPER=/path/to/nvcc_wrapper' or '-DKokkos_ROOT=/path/to/install'"
          )
        endif()

        set(INP_USE_COMPILER_LAUNCHER
            ${CMAKE_CXX_COMPILER_LAUNCHER};${Kokkos_COMPILE_LAUNCHER};${Kokkos_NVCC_WRAPPER};${CMAKE_CXX_COMPILER}
        )
        set(INP_USE_LINKER_LAUNCHER
            ${CMAKE_CXX_LINKER_LAUNCHER};${Kokkos_COMPILE_LAUNCHER};${Kokkos_NVCC_WRAPPER};${CMAKE_CXX_COMPILER}
        )
    endif()
  endif()

  set(COMPILE_TARGETS ${INP_TARGET})
  set(LINK_TARGETS ${INP_TARGET};${INP_LINK_ONLY_TARGET})

  #resolve projects to directory
  if(INP_GLOBAL)
    message(DEBUG "Kokkos marking directory ${PROJECT_SOURCE_DIR} to contain kokkos targets")
    list(APPEND INP_DIRECTORY ${CMAKE_SOURCE_DIR})
    unset(INP_GLOBAL)
  endif()

  #set properties on directories
  foreach(directory IN LISTS INP_DIRECTORY)
    kokkos_get_directory_targets(
      FOUND_TARGETS DIRECTORY_TARGETS SEARCH_DIR ${directory} EXCLUDE_DIRS ${Kokkos_EXCLUDE_BUILD_DIRS}
    )

    foreach(directory_target IN LISTS DIRECTORY_TARGETS)
      #FIXME the list of libs "Kokkos::..." that is hardcoded below should be automatically generated to reduce mainteneance burden
      kokkos_check_compile_dependency(
        compile_dependency
        transitive_compile_dependency
        link_dependency
        "Kokkos::kokkoscore;Kokkos::kokkoscontainers;Kokkos::kokkosalgorithms;Kokkos::kokkossimd;Kokkos::kokkos"
        ${directory_target}
        KOKKOS_LINK_DEPENDENCY_CACHE
        KOKKOS_PUBLIC_DEPENDENCY_CACHE
      )
      if(compile_dependency)
        list(APPEND DIRECTORY_COMPILE_TARGETS ${directory_target})
        list(APPEND COMPILE_TARGETS ${directory_target})
      endif()

      if(link_dependency)
        list(APPEND LINK_TARGETS ${directory_target})
      endif()
    endforeach()
  endforeach()

  if(INP_USE_COMPILER_LAUNCHER)
    foreach(target IN LISTS COMPILE_TARGETS)
      message(DEBUG "Kokkos setting compiler launcher ${INP_USE_COMPILER_LAUNCHER} on target ${target}")
      set_property(TARGET ${target} PROPERTY CXX_COMPILER_LAUNCHER ${INP_USE_COMPILER_LAUNCHER})
    endforeach()
  endif()

  foreach(target IN LISTS LINK_TARGETS)
    # use launcher on targets
    if(INP_USE_LINKER_LAUNCHER)
      message(DEBUG "Kokkos setting linker launcher ${INP_USE_LINKER_LAUNCHER} on target ${target}")
      set_property(TARGET ${target} PROPERTY CXX_LINKER_LAUNCHER ${INP_USE_LINKER_LAUNCHER})
    endif()

    # do nothing if the CXX compiler is capable of consuming kokkos directly
  endforeach()
endfunction()

# this function is provided to easily select which files use the same compiler as Kokkos
# when it was installed (or nvcc_wrapper):
#
#       GLOBAL      --> all files
#       TARGET      --> all files in a target
#       SOURCE      --> specific source files
#       DIRECTORY   --> all files in directory
#       PROJECT     --> all files/targets in a project/subproject
#
# Use the COMPILER argument to specify a compiler, if needed. By default, it will
# set the values to ${Kokkos_CXX_COMPILER} unless Kokkos_ENABLE_CUDA=ON and
# Kokkos_CXX_COMPILER_ID is NVIDIA, then it will set it to nvcc_wrapper
#
# Use CHECK_CUDA_COMPILES to run a check when CUDA is enabled
#
function(kokkos_compilation)
  cmake_parse_arguments(
    COMP "GLOBAL;PROJECT;CHECK_CUDA_COMPILES" "COMPILER" "DIRECTORY;TARGET;SOURCE;COMMAND_PREFIX" ${ARGN}
  )

  # if built w/o CUDA support, we want to basically make this a no-op
  set(_Kokkos_ENABLE_CUDA @Kokkos_ENABLE_CUDA@)

  if(CMAKE_VERSION VERSION_GREATER_EQUAL 3.17)
    set(MAYBE_CURRENT_INSTALLATION_ROOT "${CMAKE_CURRENT_FUNCTION_LIST_DIR}/../../..")
  endif()

  # search relative first and then absolute
  set(_HINTS "${MAYBE_CURRENT_INSTALLATION_ROOT}" "@CMAKE_INSTALL_PREFIX@")

  # find kokkos_launch_compiler
  find_program(
    Kokkos_COMPILE_LAUNCHER
    NAMES kokkos_launch_compiler
    HINTS ${_HINTS}
    PATHS ${_HINTS}
    PATH_SUFFIXES bin
  )

  if(NOT Kokkos_COMPILE_LAUNCHER)
    message(
      FATAL_ERROR
        "Kokkos could not find 'kokkos_launch_compiler'. Please set '-DKokkos_COMPILE_LAUNCHER=/path/to/launcher'"
    )
  endif()

  # if COMPILER was not specified, assume Kokkos_CXX_COMPILER
  if(NOT COMP_COMPILER)
    set(COMP_COMPILER ${Kokkos_CXX_COMPILER})
    if(_Kokkos_ENABLE_CUDA AND Kokkos_CXX_COMPILER_ID STREQUAL NVIDIA)
      # find nvcc_wrapper
      find_program(
        Kokkos_NVCC_WRAPPER
        NAMES nvcc_wrapper
        HINTS ${_HINTS}
        PATHS ${_HINTS}
        PATH_SUFFIXES bin
      )
      # fatal if we can't nvcc_wrapper
      if(NOT Kokkos_NVCC_WRAPPER)
        message(
          FATAL_ERROR "Kokkos could not find nvcc_wrapper. Please set '-DKokkos_NVCC_WRAPPER=/path/to/nvcc_wrapper'"
        )
      endif()
      set(COMP_COMPILER ${Kokkos_NVCC_WRAPPER})
    endif()
  endif()

  # check that the original compiler still exists!
  if(NOT EXISTS ${COMP_COMPILER})
    message(FATAL_ERROR "Kokkos could not find original compiler: '${COMP_COMPILER}'")
  endif()

  # try to ensure that compiling cuda code works!
  if(_Kokkos_ENABLE_CUDA AND COMP_CHECK_CUDA_COMPILES)

    # this may fail if kokkos_compiler launcher was used during install
    kokkos_cxx_compiler_cuda_test(_COMPILES_CUDA ${Kokkos_COMPILE_LAUNCHER} ${COMP_COMPILER} ${CMAKE_CXX_COMPILER})

    # if above failed, throw an error
    if(NOT _COMPILES_CUDA)
      message(FATAL_ERROR "kokkos_cxx_compiler_cuda_test failed! Test commands:\n${_COMPILES_CUDA_COMMANDS}")
    endif()
  endif()

  if(COMP_COMMAND_PREFIX)
    set(_PREFIX "${COMP_COMMAND_PREFIX}")
    string(REPLACE ";" " " _PREFIX "${COMP_COMMAND_PREFIX}")
    set(Kokkos_COMPILER_LAUNCHER "${_PREFIX} ${Kokkos_COMPILE_LAUNCHER}")
  endif()

  if(COMP_GLOBAL)
    # if global, don't bother setting others
    set_property(
      GLOBAL PROPERTY RULE_LAUNCH_COMPILE "${Kokkos_COMPILE_LAUNCHER} ${COMP_COMPILER} ${CMAKE_CXX_COMPILER}"
    )
    set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK "${Kokkos_COMPILE_LAUNCHER} ${COMP_COMPILER} ${CMAKE_CXX_COMPILER}")
  else()
    foreach(_TYPE PROJECT DIRECTORY TARGET SOURCE)
      # make project/subproject scoping easy, e.g. KokkosCompilation(PROJECT) after project(...)
      if("${_TYPE}" STREQUAL "PROJECT" AND COMP_${_TYPE})
        list(APPEND COMP_DIRECTORY ${PROJECT_SOURCE_DIR})
        unset(COMP_${_TYPE})
      endif()
      # set the properties if defined
      if(COMP_${_TYPE})
        # MESSAGE(STATUS "Using ${COMP_COMPILER} :: ${_TYPE} :: ${COMP_${_TYPE}}")
        set_property(
          ${_TYPE} ${COMP_${_TYPE}} PROPERTY RULE_LAUNCH_COMPILE
                                             "${Kokkos_COMPILE_LAUNCHER} ${COMP_COMPILER} ${CMAKE_CXX_COMPILER}"
        )
        set_property(
          ${_TYPE} ${COMP_${_TYPE}} PROPERTY RULE_LAUNCH_LINK
                                             "${Kokkos_COMPILE_LAUNCHER} ${COMP_COMPILER} ${CMAKE_CXX_COMPILER}"
        )
      endif()
    endforeach()
  endif()
endfunction()
